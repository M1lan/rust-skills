---
name: rust-pin
description: "Pin and self-referential types: Pin, Unpin, futures, generators, and pin projection. Triggers: Pin, Unpin, self-referential, Future, async, Generator"
globs: ["**/*.rs"]
---

# Pin and Self-Referential Types

## Core issues

Key question: How do we ensure pointers stay valid in async or self-referential
structures?

Pin ensures that certain values do not move in memory.

---

## When do you need Pin?

### Future of async/await

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

struct MyFuture {
 state: State,
}

impl Future for MyFuture {
 type Output = ();

 fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
 let this = self.get_mut();
 // Safe use this.state
 Poll::Ready(())
 }
}
```

### 2. Self-referential structures

```rust
use std::pin::Pin;

struct Node {
 value: i32,
 parent: Option<Pin<Box<Node>>>, // Self-referential pointer
}
```

---

## Common Pin forms

| Form          | Scenario                       | Example         |
|---------------|--------------------------------|-----------------|
| `Pin<&T>`     | Shared borrow, value immovable | `Pin<&Foo>`     |
| `Pin<&mut T>` | Mutable borrow                 | `Pin<&mut Foo>` |
| `Pin<Box<T>>` | Heap-allocated value           | `Pin<Box<Foo>>` |
| `Pin<Arc<T>>` | Shared heap allocation         | `Pin<Arc<Foo>>` |

---

## Unpin marker

```rust
// Types that are Unpin can be safely moved.
struct MyType {
 data: Vec<u8>,
}

// Most types are Unpin automatically.
// Types that are often !Unpin:
// - Futures generated by async/await
// - Generators
// - Types that contain self-references

struct NotUnpinType {
 // Contains a self-referential pointer
 ptr: *const Self,
}

impl !Unpin for NotUnpinType {}
```

---

## Pin projection

```rust
struct Wrapper<T> {
 inner: T,
 extra: String,
}

impl<T> Wrapper<T> where T: Unpin {
    // Project a pinned wrapper to a pinned inner value.
    fn project(self: Pin<&mut Self>) -> Pin<&mut T> {
        // SAFETY: Wrapper is pinned and T: Unpin, so moving inner is safe.
        unsafe { Pin::new_unchecked(&mut self.get_unchecked_mut().inner) }
    }
}
```

---

## Common errors

| Error                    | Reason                               | Solve                               |
|--------------------------|--------------------------------------|-------------------------------------|
| Forgetting to pin        | Future may move                      | Use Pin/Box::pin                    |
| Unsafe projection misuse | Violates pinning rules               | Use `pin_project` or correct unsafe |
| Misusing Unpin           | Pointers become invalid across await | Understand future state layout      |

---

## When you don't need Pin

- Sync code without futures
- Data structures with no self-references
- Short-lived stack values
- Values that are guaranteed not to move

---

## Quick check

| Scenario           | Need Pin? |
|--------------------|-----------|
| `async { ... }`    | ✅ Yes    |
| `Box<dyn Future>`  | ✅ Need   |
| Future             | ✅ Need   |
| Normal Vec         | ❌ No     |
| Thread locals      | ❌ No     |
| No self-references | ❌ No     |
